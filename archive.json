{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-12-03T00:16:36.319192+00:00",
  "repo": "alvestrand/id-abs-capture-timestamp",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOM2BX7c6coMLq",
      "title": "RTP topologies",
      "url": "https://github.com/alvestrand/id-abs-capture-timestamp/issues/2",
      "state": "OPEN",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 1\r\n\r\n\"However, when multiple hops and multiple systems are involved, this task becomes more difficult; in particular, when one desires to synchronize media from multiple sources with independent clocks, where the media may have traveled over multiple network hops between the source and destination.This memo describes one mechanism for providing more information to make such synchronization possible.\"\r\n\r\n[BA]  Is the sole use case for this document \"lip sync\" from a single source?  Or are other use cases possible too (e.g. synchronized concert)?\r\n\r\nAs written, this section could be interpreted to apply to a wide range of RTP topologies described in RFC 7667. Since RTCP termination is mentioned in Section 3, this does not appear to be the intent.  I'd suggest adding a paragraph describing the RTP topologies to which this specification applies (e.g. Section 3.6 and 3.7 of RFC 7667)\r\n\r\nSection 3.1.2.1\r\n\r\n\" Absolute capture timestamp is the NTP timestamp of when the first frame in a packet was originally captured. This timestamp MUST be based on the same clock as the clock used to generate NTP timestamps for RTCP sender reports on the capture system.\"\r\n\r\n[BA] Does this imply that the RTCP SR NTP timestamp from the capturing system is placed in this field?\r\n\r\nSection 3.1.2.2\r\n\r\n   Estimated capture clock offset is the sender's estimate of the offset\r\n   between its own NTP clock and the capture system's NTP clock.  The\r\n   sender is here defined as the system that owns the NTP clock used to\r\n   generate the NTP timestamps for the RTCP sender reports on this\r\n   stream.  The sender system is typically either the capture system or\r\n   a mixer.\r\n\r\n[BA] In an RTCP-terminating topology wouldn't the mixer/SFM be the sender?  In what topology would the capture system be the sender?\r\n\r\nSection 3.1.3.2\r\n\r\n   An intermediate system (e.g. mixer) MAY adjust these timestamps as\r\n   needed.  It MAY also choose to rewrite the timestamps completely,\r\n   using its own NTP clock as reference clock, if it wants to present\r\n   itself as a capture system for A/V-sync purposes.\r\n\r\n[BA] Wouldn't this behavior be governed by the topology? For example, an RTCP-terminating middle box uses its own NTP clock, but presumably a translator would not. ",
      "createdAt": "2024-10-31T20:38:02Z",
      "updatedAt": "2024-11-09T15:19:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alvestrand",
          "authorAssociation": "OWNER",
          "body": "> Section 1\r\n> \r\n> \"However, when multiple hops and multiple systems are involved, this task becomes more difficult; in particular, when one desires to synchronize media from multiple sources with independent clocks, where the media may have traveled over multiple network hops between the source and destination.This memo describes one mechanism for providing more information to make such synchronization possible.\"\r\n> \r\n> [BA] Is the sole use case for this document \"lip sync\" from a single source? Or are other use cases possible too (e.g. synchronized concert)?\r\n\r\nIt's been envisaged for synchronizing audio and video from multiple independent sources, for instance from multiple microphones on independent systems in the same room.\r\n\r\nThe other prominent use case is statistics on end-to-end delay; for this use case, the fact that the estimates will be wrong some of the time doesn't matter as long as they're mostly correct most of the time.\r\n\r\n> \r\n> As written, this section could be interpreted to apply to a wide range of RTP topologies described in RFC 7667. Since RTCP termination is mentioned in Section 3, this does not appear to be the intent. I'd suggest adding a paragraph describing the RTP topologies to which this specification applies (e.g. Section 3.6 and 3.7 of RFC 7667)\r\n\r\nThe main scenario supported is an RTP-terminating mixer (3.6, 3.9).\r\nI'll have to scratch my head a bit about what will happen in other scenarios.\r\n\r\n> Section 3.1.2.1\r\n> \r\n> \" Absolute capture timestamp is the NTP timestamp of when the first frame in a packet was originally captured. This timestamp MUST be based on the same clock as the clock used to generate NTP timestamps for RTCP sender reports on the capture system.\"\r\n> \r\n> [BA] Does this imply that the RTCP SR NTP timestamp from the capturing system is placed in this field?\r\n\r\nNo. If they originate from the same clock, the offset field from the originating system will be zero.\r\nHowever, the RTCP SR NTP timestamp is produced when the RTCP SR is sent, not when the frame is captured.\r\n\r\n> \r\n> Section 3.1.2.2\r\n> \r\n> Estimated capture clock offset is the sender's estimate of the offset between its own NTP clock and the capture system's NTP clock. The sender is here defined as the system that owns the NTP clock used to generate the NTP timestamps for the RTCP sender reports on this stream. The sender system is typically either the capture system or a mixer.\r\n> \r\n> [BA] In an RTCP-terminating topology wouldn't the mixer/SFM be the sender? In what topology would the capture system be the sender?\r\n\r\nPoint-to-point and point-to-multipoint (RFC  7667 3.1, 3.2, 3.4, 3.7) are the obvious ones. As long as the delay estimation algorithm runs between the capture system and the consumer system. In all RTCP-terminating topologies, the middle box is the sender.\r\n> \r\n> Section 3.1.3.2\r\n> \r\n> An intermediate system (e.g. mixer) MAY adjust these timestamps as needed. It MAY also choose to rewrite the timestamps completely, using its own NTP clock as reference clock, if it wants to present itself as a capture system for A/V-sync purposes.\r\n> \r\n> [BA] Wouldn't this behavior be governed by the topology? For example, an RTCP-terminating middle box uses its own NTP clock, but presumably a translator would not.\r\n\r\nRight. See above. Would be good to say \"An intermediate RTCP-terminating system\" instead of just \"an intermediate system\", for clarity.\r\n",
          "createdAt": "2024-10-31T21:32:18Z",
          "updatedAt": "2024-10-31T21:32:18Z"
        },
        {
          "author": "Arctunix",
          "authorAssociation": "NONE",
          "body": "> > Section 1\r\n> > \"However, when multiple hops and multiple systems are involved, this task becomes more difficult; in particular, when one desires to synchronize media from multiple sources with independent clocks, where the media may have traveled over multiple network hops between the source and destination.This memo describes one mechanism for providing more information to make such synchronization possible.\"\r\n> > [BA] Is the sole use case for this document \"lip sync\" from a single source? Or are other use cases possible too (e.g. synchronized concert)?\r\n> \r\n> It's been envisaged for synchronizing audio and video from multiple independent sources, for instance from multiple microphones on independent systems in the same room.\r\n\r\nThere are two separate ways to accomplish lip sync using abs-capture-time:\r\n\r\n1) Take the \"absolute capture timestamp\" associated with each audio and media frame and sync according to that. This has perfect accuracy but only works if the audio and media was originally captured and timestamped on the same system.\r\n\r\n2) For each audio and media frame, calculate the one-way delay from capture to receiver using both \"absolute capture timestamp\" and \"estimated capture clock offset\". Lip sync based on one-way delay. This works across multiple capture systems (e.g. synchronized concerts) but is less accurate as it involves a series of clock offset calculations on each RTCP-terminating hop.\r\n\r\n> > As written, this section could be interpreted to apply to a wide range of RTP topologies described in RFC 7667. Since RTCP termination is mentioned in Section 3, this does not appear to be the intent. I'd suggest adding a paragraph describing the RTP topologies to which this specification applies (e.g. Section 3.6 and 3.7 of RFC 7667)\r\n> \r\n> The main scenario supported is an RTP-terminating mixer (3.6, 3.9). I'll have to scratch my head a bit about what will happen in other scenarios.\r\n\r\nThe core principle is that RTCP-terminating endpoints must either a) update \"estimated capture clock offset\" or b) remove \"estimated capture clock offset\" if it resends the media frame to the next hop. The \"absolute capture timestamp\" part should be resent as-is (or maybe _slightly_ adjusted - see further down).\r\n\r\nEndpoints that do not terminate RTCP should forward the abs-capture-time header extension as-is.\r\n\r\n> > Section 3.1.3.2\r\n> > An intermediate system (e.g. mixer) MAY adjust these timestamps as needed. It MAY also choose to rewrite the timestamps completely, using its own NTP clock as reference clock, if it wants to present itself as a capture system for A/V-sync purposes.\r\n> > [BA] Wouldn't this behavior be governed by the topology? For example, an RTCP-terminating middle box uses its own NTP clock, but presumably a translator would not.\r\n> \r\n> Right. See above. Would be good to say \"An intermediate RTCP-terminating system\" instead of just \"an intermediate system\", for clarity.\r\n\r\nI think we've accidentally mixed different concepts up in this section:\r\n\r\n1) An intermediate RTCP-terminating system MUST either a) update \"estimated capture clock offset\" or b) remove \"estimated capture clock offset\" when it resends a media frame since the RTCP-terminating system ahs its own NTP clock. Translators typically don't change the NTP clock so they should forward the offset as-is.\r\n\r\n2) An intermediate system (both RTCP-terminating and non-terminating ones) may want to rewrite the timestamps for other reasons. We could for example have an audio transcoder as the intermediate system. The transcoding step will likely \"shift\" the timestamps a bit (e.g. add 3 ms of audio latency due to internal buffers in audio codecs). Adjustments to \"absolute capture timestamp\" are then needed, which is the purpose of this sentence: \"An intermediate system (e.g. mixer) MAY adjust these timestamps as needed.\"\r\n\r\n3) An intermediate system may also want to \"pretend\" that it's the capture system. A highly complex mixer could for example take multiple audio and video streams and do lip sync and other fancy things in the mixer. So that's where this sentence comes in: \"It MAY also choose to rewrite the timestamps completely, using its own NTP clock as reference clock, if it wants to present itself as a capture system for A/V-sync purposes.\"\r\n\r\nConfusing! :-)",
          "createdAt": "2024-11-09T10:32:35Z",
          "updatedAt": "2024-11-09T15:19:06Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOM2BX7c6c5eGu",
      "title": "Year 2036 Considerations",
      "url": "https://github.com/alvestrand/id-abs-capture-timestamp/issues/3",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Raised by Jonathan Lennox:\r\n\r\nDraft should describe how to deal with the NTP timestamp overflow in 2036.\r\n\"Interpret as closest time to current time\" is probably Good Enough.\r\n",
      "createdAt": "2024-11-04T09:41:24Z",
      "updatedAt": "2024-11-05T10:33:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "RFC 5905 [NTPv4] Section 4 gives the formulas this, computing the \"era\" from the current time, and then evaluating an NTP timestamp in the context of the era.",
          "createdAt": "2024-11-05T10:33:05Z",
          "updatedAt": "2024-11-05T10:33:05Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOM2BX7c6c5fMR",
      "title": "Describe timestamps for stored media",
      "url": "https://github.com/alvestrand/id-abs-capture-timestamp/issues/4",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Raised by Jonathan Lennox:\r\n\r\nStored media doesn't have an obvious candidate for \"the capture time\". It's definitely not \"now\".\r\n\r\nSuggestion is to pick a number for the start of the media, record the offset between the local clock and that into the offset, and increase the \"capture\" timestamp by the clock recovered from the media.\r\n\r\nZero may be a fine number.\r\n",
      "createdAt": "2024-11-04T09:43:35Z",
      "updatedAt": "2024-11-04T09:43:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOM2BX7c6dD-Ld",
      "title": "Describe how the capture time offset is consumed",
      "url": "https://github.com/alvestrand/id-abs-capture-timestamp/issues/5",
      "state": "OPEN",
      "author": "JonathanLennox",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There's a lot of confusion about the capture time offset field, so it'd be useful to describe (at a high level) some examples of code that uses it, and explains why the plain capture time isn't sufficient.",
      "createdAt": "2024-11-05T10:35:22Z",
      "updatedAt": "2024-11-09T10:35:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Arctunix",
          "authorAssociation": "NONE",
          "body": "Perhaps an explicit mention of that it's main purpose is to facilitate the calculation of one-way delay? Other functionality (e.g. lip sync across multiple capture systems) would then derive from that.",
          "createdAt": "2024-11-09T10:35:02Z",
          "updatedAt": "2024-11-09T10:35:02Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOM2BX7c59fY5n",
      "title": "Fix a couple typos",
      "url": "https://github.com/alvestrand/id-abs-capture-timestamp/pull/1",
      "state": "MERGED",
      "author": "Orphis",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`travelled` is British English while `traveled` is US English. As the rest of the document seems to be conforming to US English, it should be updated.",
      "createdAt": "2024-10-03T11:49:11Z",
      "updatedAt": "2024-10-03T11:52:53Z",
      "baseRepository": "alvestrand/id-abs-capture-timestamp",
      "baseRefName": "main",
      "baseRefOid": "df96ba28f0405038ecc730cad95d57264d8197f1",
      "headRepository": "Orphis/id-abs-capture-timestamp",
      "headRefName": "patch-1",
      "headRefOid": "b5d90deec8409d38a236e3676546d2df9623e71f",
      "closedAt": "2024-10-03T11:52:53Z",
      "mergedAt": "2024-10-03T11:52:53Z",
      "mergedBy": "alvestrand",
      "mergeCommit": {
        "oid": "2635eb3599a6b4fb5650d9025c384f9092be1299"
      },
      "comments": [],
      "reviews": []
    }
  ]
}